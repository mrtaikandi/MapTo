using MapTo.CodeAnalysis;
using MapTo.Configuration;

namespace MapTo.Tests.SourceBuilders;

internal static class TestSourceOutputCompilation
{
    internal static CompilationResult Compile(this ITestSourceBuilder builder, bool assertOutputCompilation = true) =>
        Compile(builder, assertOutputCompilation, s => !s.AutoGenerated);

    internal static CompilationResult Compile(this ITestSourceBuilder builder, params ITestFileBuilder[] sourceFile) =>
        builder.Compile(s => sourceFile.Any(f => f.Name == s.FileName));

    internal static CompilationResult Compile(this ITestSourceBuilder builder, Func<TestSource, bool> testSourceFilter) =>
        Compile(builder, true, testSourceFilter);

    internal static CompilationResult Compile(this ITestSourceBuilder builder, bool assertOutputCompilation, Func<TestSource, bool> testSourceFilter)
    {
        var sources = builder.Build();
        var analyzerConfigOptions = builder.Options.AnalyzerConfigOptions;
        analyzerConfigOptions.TryAdd(
            AnalyzerConfigOptionsExtensions.GetBuildPropertyName(nameof(CodeGeneratorOptions.GenerateXmlDocument)),
            builder.Options.GenerateXmlDoc.ToString());

        return CSharpGenerator.GetOutputCompilation(
            sources.Where(testSourceFilter),
            languageVersion: builder.Options.LanguageVersion,
            nullableContextOptions: builder.Options.SupportNullReferenceTypes ? NullableContextOptions.Enable : NullableContextOptions.Disable,
            analyzerConfigOptions: analyzerConfigOptions,
            assertOutputCompilation: assertOutputCompilation);
    }

    internal static void CompileAndAssertExpectedGeneratedContent(this ITestSourceBuilder builder)
    {
        var (compilation, diagnostics) = builder.Compile();

        diagnostics.ShouldBeSuccessful();
        compilation.GetLastSyntaxTreeString().ShouldBe(builder.GetExpectedFileContent());
    }
}